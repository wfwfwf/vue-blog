(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{822:function(l,e,t){"use strict";t.r(e);var o=t(5),s=Object(o.a)({},(function(){var l=this,e=l.$createElement,t=l._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[t("h2",{attrs:{id:"如何保留滚动条位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何保留滚动条位置"}},[l._v("#")]),l._v(" 如何保留滚动条位置")]),l._v(" "),t("p",[l._v("在vue项目中，我们可能会遇到这样的需求，例如：")]),l._v(" "),t("p",[l._v("商品列表页中，点击某一商品，进入到详情页。")]),l._v(" "),t("p",[l._v("从详情页中返回到商品列表页，页面应当显示的页面应当是之前的样子。")]),l._v(" "),t("p",[l._v("也就是说，滚动条的位置应该缓存下来；")]),l._v(" "),t("p",[l._v("思路 商品列表需要被缓存下来,页面的缓存方式请查看vue官方文档keep-alive来缓存页面，这样，在详情页面返回的时候，页面不至于重新加载。 在商品列表生命周期activated中，监听当前scrollContainer父元素的滚动事件，滚动时的回调中，获取到scrollTop(滚动条距离滚动元素即scrollContainer的距离)的值，存入到以及在deactivated中移除掉当前滚动事件的监听。 在商品列表中，点击进入详情页中的时候，将滚动条位置被缓存下来了，你可以放到sessionStorage|localStorage中。当然，如果你使用了vuex，可以直接将值放入vuex中进行管理； 从详情页中返回的时候，同时要做这样的操作，将你存入缓存中的scrollTop值重新赋予给当前div的滚动条 Ok，思路就是这样子，大功告成。 vue中具体实现 我是用的vuex进行管理的滚动条位置，实现代码如下：")]),l._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[l._v('<div class="scrollContainer" ref="scroll">    //加了一个ref，用于获取当前dom \n     <ul>\n       <li>1</li>\n       <li>2</li>\n       <li>3</li>\n       <li>4</li>\n       <li>5</li>\n       <li>6</li>\n       <li>7</li>\n       <li>8</li>\n       <li>9</li>\n       <li>10</li>  \n     </ul>\n</div>\ncomputed:{\n    ...mapGetters([\n          "home_list_top"    //vuex中的存放的滚动条的位置\n    ])\n}\n...\nmethods:{\n    recordScrollPosition(e) {\n      this.$store.dispatch("setHomeListTop",e.target.scrollTop);    //实时存入到vuex中\n    }\n}\n...\nactivated(){  //滚动条位置的监听放到activated是因为此页面被keep-alive缓存了\n    this.$refs.scroll.scrollTop = this.home_list_top;        //this.$refs.scroll拿到滚动的dom，即scrollContainer，this.home_list_top是存入到vuex里的值\n    this.$refs.scroll.addEventListener("scroll",this.recordScrollPosition);    //添加绑定事件\n},\ndeactivated(){  //keep-alive 的页面跳转时，移除scroll事件\n    this.$refs.scroll.removeEventListener("scroll",this.recordScrollPosition);  //清除绑定的scroll事件\n}\n')])])]),t("h2",{attrs:{id:"webkit-overflow-scrolling介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webkit-overflow-scrolling介绍"}},[l._v("#")]),l._v(" -webkit-overflow-scrolling介绍")]),l._v(" "),t("p",[l._v("-webkit-overflow-scrolling: auto | touch;\nauto： 普通滚动，当手指从触摸屏上移开，滚动立即停止 touch：滚动回弹效果，当手指从触摸屏上移开，内容会保持一段时间的滚动效果，继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。")]),l._v(" "),t("p",[l._v("兼容写法")]),l._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[l._v("over-flow: auto;     /* winphone8和android4+ */\n-webkit-overflow-scrolling: touch;    /* ios5+ */\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);